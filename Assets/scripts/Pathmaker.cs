using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
// MAZE PROC GEN LAB
// all students: complete steps 1-6, as listed in this file
// optional: if you're up for a bit of a mind safari, complete the "extra tasks" to do at the very bottom

public class Pathmaker : MonoBehaviour {

    //	Declare a private integer called counter that starts at 0; 		// counter will track how many floor tiles I've instantiated
    private int counter = 0;

    //total number of tiles generated by the pathmakers
    public static int countTile = 0;
    public static int materialNum = 0;

    public Material[] materials;

    public static Vector3 posSum = new Vector3(0,160,0);
    public static int maxTile = 400;
    private float speed = 5f;

    public static float createPathPercent = 0.98f;
    public static float rPercent1 = 0.25f;
    public static float rPercent2 = 0.5f;

    public bool randomizeRotatePercent = false;
    public bool randomizeLifeSpan = false;
    
    
    //set the lifespan of the path maker
    public int lifespan = 50;    

    //	Declare a public Transform called floorPrefab, assign the prefab in inspector;
    public Transform floorPrefab;
    //	Declare a public Transform called pathmakerSpherePrefab, assign the prefab in inspector; 		
    public Transform pathmakerSpherePrefab;

    private GameObject mainCamera;
    private GameObject canvas;




    private void Start()
    {
        mainCamera = GameObject.Find("Main Camera");
        canvas = GameObject.Find("Canvas");

        if (randomizeRotatePercent) {
            rPercent1 = Random.Range(0f, 0.5f);
            rPercent2 = Random.Range(rPercent1, 0.5f);
        }

        if (randomizeLifeSpan) {
            lifespan = Random.Range(30, 100);
        }

        
        floorPrefab.GetComponent<MeshRenderer>().material = materials[materialNum];
    }
    void Update () {

        if (counter < lifespan)
        {
            var rnum = Random.Range(0f, 1.0f);
            if (rnum < rPercent1)
                this.transform.Rotate(0, 90, 0);
            else if (rnum < rPercent2)
                this.transform.Rotate(0, -90, 0);
            else if (rnum > createPathPercent && rnum < 1.0f)
            {
                Instantiate(pathmakerSpherePrefab, this.transform.position, Quaternion.Euler(0,0,0));
            }

            if (countTile < maxTile)
            {
                Collider[] hitColliders = Physics.OverlapSphere(this.transform.position, 0.5f);

                // AVOID SPAWNING A TILE IN THE SAME PLACE AS ANOTHER TILE 
                if (hitColliders.Length == 1)
                {
                    Instantiate(floorPrefab, this.transform.position, Quaternion.Euler(0, 0, 0));
                    posSum += this.transform.position;
                }

                countTile++;
            }
            else Destroy(this.gameObject);

            //move the camera position to the average position of tiles
            mainCamera.transform.position = new Vector3(posSum.x/(countTile+1), 160, posSum.z/(countTile+1));
            canvas.transform.position = new Vector3(posSum.x / (countTile + 1), 0, posSum.z / (countTile + 1));
            this.transform.Translate(Vector3.forward*speed);

            counter++;
        }
        else {
            Destroy(this.gameObject);
        }


//		If counter is less than 50, then:
//			Generate a random number from 0.0f to 1.0f;
//			If random number is less than 0.25f, then rotate myself 90 degrees;
//				... Else if number is 0.25f-0.5f, then rotate myself -90 degrees;
//				... Else if number is 0.99f-1.0f, then instantiate a pathmakerSpherePrefab clone at my current position;
//			// end elseIf

//			Instantiate a floorPrefab clone at current position;
//			Move forward ("forward", as in, the direction I'm currently facing) by 5 units;
//			Increment counter;
//		Else:
//			Destroy my game object; 		// self destruct if I've made enough tiles already
	}

} 




// tune your values...

// how would you tune the probabilities to generate lots of long hallways? does it... work?
// tweak all the probabilities that you want... 


// STEP 6:  =====================================================================================
// art pass, usability pass


// BETTER UI:
// learn how to use UI Sliders (https://unity3d.com/learn/tutorials/topics/user-interface-ui/ui-slider) 
// let us tweak various parameters and settings of our tech demo
// let us click a UI Button to reload the scene, so we don't even need the keyboard anymore.  Throw that thing out!

// WALL GENERATION
// add a "wall pass" to your proc gen after it generates all the floors
// 1. raycast downwards around each floor tile (that'd be 8 raycasts per floor tile, in a square "ring" around each tile?)
// 2. if the raycast "fails" that means there's empty void there, so then instantiate a Wall tile prefab
// 3. ... repeat until walls surround your entire floorplan
// (technically, you will end up raycasting the same spot over and over... but the "proper" way to do this would involve keeping more lists and arrays to track all this data)
